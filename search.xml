<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-表]]></title>
    <url>%2F2018%2F06%2F02%2Flist%2F</url>
    <content type="text"><![CDATA[表 LinkedList链表的一个基本概念，节点，在该类中定义为内部类由此内部类可以看出，linkedList不是简单的单链表，而是双向链表，既知前驱又知后继，因此进行操作的时候需要维护两个指针 12345678910private static class Node&lt;E&gt; &#123; E item; //当前节点 Node&lt;E&gt; next; // 后一个节点 Node&lt;E&gt; prev; // 前一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 获取第i个节点 1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;// 获取index位置的NodeNode&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // size &gt;&gt; 1此为size的一半 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 增加元素 linkedList add元素是添加到该表的结尾的 1234public boolean add(E e) &#123; linkLast(e); return true;&#125; //主要方法在于linkLast 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 指定位置添加元素 12345678public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 主要实现就在linkBefore里面了 123456789101112131415 void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 获取插入位置前一节点 final Node&lt;E&gt; pred = succ.prev; // 建立要插入的节点，并链接上下一个节点，即s.next = p.next final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; // 如果没有前驱，则新加节点为第一个节点 if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 创建新链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;// ------------addAll(c)------------public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;// --------------addAll(size,c)------------------public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 其实就是判断index &gt;= 0 &amp;&amp; index &lt;= size checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123;// 初始化链表走这一分路 succ = null; pred = last; &#125; else &#123;// 指定位置插入 succ = node(index); pred = succ.prev; &#125; //遍历collection，一个一个插入 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode;// 每次新建的节点下次就变成了前驱 &#125; if (succ == null) &#123;// 没错，就是初始化才走这个 last = pred; &#125; else &#123;// 指定位置的指针维护 pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析]]></title>
    <url>%2F2018%2F06%2F02%2FAlgorithm%2F</url>
    <content type="text"><![CDATA[只要在常数时间内可以将问题的大小削减为其一部分（$ \frac{1}{2} $）, 那么该算法就是($O(logN)$) 最大子序列和问题($O(NlogN)$) 123456789101112public static int maxSubSum(int[] arr) &#123; int maxSum = 0, thisSum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; thisSum += arr[i]; if (thisSum &gt; maxSum) &#123; maxSum = thisSum; &#125; else if (thisSum &lt; 0) &#123; thisSum = 0; &#125; &#125; return maxSum;&#125; 折半查找binary search($O(logN)$) 1234567891011121314public static int binarySearch(int[] arr, int x) &#123; int low = 0, high = arr.length - 1; while (low &lt;= high) &#123; int mid = (low + high)/2; if (arr[mid] &lt; x) &#123; low = ++mid; &#125; else if (arr[mid] &gt; x) &#123; high = --mid; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Next 安装的一些问题]]></title>
    <url>%2F2018%2F05%2F24%2Fother%2F</url>
    <content type="text"><![CDATA[这次装next主题的时候，遇到了一些问题：在站点配置文件中可以配置如下：1234deploy: type: git repository: git@github.com:&#123;name&#125;/&#123;name&#125;.github.io.git branch: master 配置其他的请参考：hexo 第三方的配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[几大排序算法的Java实现]]></title>
    <url>%2F2018%2F05%2F08%2FSortAlgorithm%2F</url>
    <content type="text"><![CDATA[更新中… 注： 该类中附有随机生成[min, max)范围不重复整数的方法，如果各位看官对此方法有什么更好的建议，欢迎提出交流。 各个算法的思路都写在该类的注释中了，同时也方便各位进行本地环境验证。 目前已完成的排序算法有：冒泡排序、选择排序、插入排序。 暂时只提供这些排序算法的基本版，对算法的改进暂时不做考虑。 如果想看的更直观些，欢迎访问一个可视化的排序网站 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import static org.junit.Assert.*;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Test;public class SortTest &#123; /** * 用来存储给定范围内所有的整数 */ private static List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); /** * 返回随机生成的[min, max)之间的整数数组 * @param min 最小值 * @param max 最大值(不包含） * @return */ public static Integer[] generateRandomNum(int min, int max) &#123; return generateRandomNum(min, max, (max - min)); &#125; /** * 返回随机生成的[min, max)之间的整数数组，个数为num个 * @param min * @param max * @param num 要生成的随机数个数 * @return */ public static Integer[] generateRandomNum(int min, int max, int num) &#123; long start = System.currentTimeMillis(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = min; i &lt; max; i++) &#123; numList.add(i); &#125; for (int i = 0; i &lt; num; i++) &#123; result.add(generateOneNum(min, max)); &#125; long end = System.currentTimeMillis(); System.out.println("生成的随机数组范围是：[" + min + ", " + max + "), 个数： " + num + ", 耗时： " + (end - start) / 1000.0 + "s.\n待排序数组为： " + result); return result.toArray(new Integer[]&#123;&#125;); &#125; // 读取numList中的任意元素 private static int generateOneNum(int min, int max) &#123; return (int) numList.remove((int) (Math.random() * numList.size())); &#125; /** * 冒泡排序算法, 时间复杂度是O(n^2) * @throws Exception */ @Test public void testBubbleSort() throws Exception &#123;// Integer nums[] = &#123; 67, 1, 69, 43, 7, 56, 34, 111, 87, 62, 89, 90, 31, 99, 100 &#125;; Integer[] nums = generateRandomNum(1, 100, 10); // 第一层for循环控制排序趟数。Reason: 1个数字-&gt;0趟排序，2个数字-&gt;1趟排序,3个数字-&gt;2趟排序 for (int i = 0; i &lt; nums.length - 1; i++) &#123; // 第二层for循环控制本趟排序的比较过程 for (int j = 0; j &lt; nums.length - 1 - i; j++) &#123; // 进行两两比较，如果后面的比前面小，则交换位置，则每进行一趟排序，最后一个数字都是该趟排序中最大的数字 if (nums[j] &gt; nums[j + 1]) &#123; int temp1 = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp1; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序结果为：" + Arrays.toString(nums)); &#125; &#125; /** * 选择排序 * @throws Exception */ @Test public void testSelectionSort() throws Exception &#123; Integer[] nums = generateRandomNum(1, 100, 10); for (int i = 0; i &lt; nums.length - 1; i++) &#123;// 仍旧是控制排序的趟数 int minIndex = i; // 该层for循环就是为了找到最小的数字并和未排序的所有数字中的首位进行交换 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; // 交换该趟排序中最小的数和未排序的数中首位数字 int tmp = nums[minIndex]; nums[minIndex] = nums[i]; nums[i] = tmp; &#125; System.out.println("第" + (i + 1) + "趟排序结果为： " + Arrays.toString(nums)); &#125; &#125; /** * 插入排序: 到要插入的数，跟已经排好序的数做比对，如果该数小于之前的数，则之前的数向后移动一位，如果出现 * 大于某个数，则在该位置插入数 * @throws Exception */ @Test public void testInsertSort() throws Exception &#123; Integer[] nums = generateRandomNum(1, 100, 10); for (int i = 1; i &lt; nums.length; i++) &#123;// 第一层for循环解决趟数 int j = i; int target = nums[i];// 获取要插入的那个数 // 因为当插入的数比原本已排好序列中的数大时停止比较，所以采用while while (j &gt; 0 &amp;&amp; target &lt; nums[j - 1]) &#123; nums[j] = nums[j - 1];// j位置放j-1处的值，相当于该值后移一位 j--; &#125; // 结束while循环时target &gt; nums[j - 1] nums[j] = target; System.out.println("第" + (i + 1) + "趟排序结果为： " + Arrays.toString(nums)); &#125; &#125; /** * 快速排序 * @throws Exception */ @Test public void testQuickSort() throws Exception &#123; Integer[] nums = generateRandomNum(1, 100, 10); &#125; /** * 关于位运算： 1 ^ 正奇数 = 正奇数 - 1 * @throws Exception */ @Test public void testName() throws Exception &#123; for (int i = 0; i &lt; 101; i++) &#123; System.out.println(1 ^ (2*i + 1)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
